<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
</head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>three.js 5A</title>
</head>
<body>
    <canvas id="c"></canvas>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@ 0.163.0/examples/jsm/"
            }
        }
    </script>
    <canvas id="c"></canvas>
    <div class="split">
       <div id="view1" tabindex="1"></div>
       <div id="view2" tabindex="2"></div>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
        import {OBJLoader} from 'three/addons/loaders/OBJLoader.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        function main() {
            

            const canvas = document.querySelector('#c');
            const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
            
            // creating PerspectiveCamera/"frustum"
            const fov = 75; // field of view. fov always in degrees.
            const aspect = 2; // canvas default
            const near = 0.1;
            const far = 21;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set = (0, 3, 0); // moves camera up x units on z-axis
            // const cameraHelper = new THREE.CameraHelper(camera);

            // const scene = new THREE.Scene();

            class MinMaxGUIHelper {
                constructor(obj, minProp, maxProp, minDif) {
                    this.obj = obj;
                    this.minProp = minProp;
                    this.maxProp = maxProp;
                    this.minDif = minDif;
                }
                get min() {
                    return this.obj[this.minProp];
                }
                set min(v) {
                    this.obj[this.minProp] = v;
                    this.obj[this.maxProp] = Math.max(this.obj[this.maxProp], v + this.minDif);
                }
                get max() {
                    return this.obj[this.maxProp];
                }
                set max(v) {
                    this.obj[this.maxProp] = v;
                    this.min = this.min;  // this will call the min setter
                }
            }

            function updateCamera() {
                camera.updateProjectionMatrix();
            }
 
            const gui = new GUI();
            gui.add(camera, 'fov', 1, 180).onChange(updateCamera);
            const minMaxGUIHelper = new MinMaxGUIHelper(camera, 'near', 'far', 0.1);
            gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
            gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far').onChange(updateCamera);

            const controls = new OrbitControls(camera, canvas);
            controls.target.set(0, 5, 0);
            controls.update();

            const scene = new THREE.Scene();
            scene.background = new THREE.Color("black");


            // ----------- draw cube -----------
            // creating a BoxGeometry (contains data for a box)
                const boxWidth = 1;
                const boxHeight = 1;
                const boxDepth = 1;
                const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
                const cubes = [];

            // ADDING TEXTURES
                const loader = new THREE.TextureLoader();
                const materials = [
                    new THREE.MeshBasicMaterial({ map: loadColorTexture('https://fastly.picsum.photos/id/16/2500/1667.jpg?hmac=uAkZwYc5phCRNFTrV_prJ_0rP0EdwJaZ4ctje2bY7aE')}),
                    new THREE.MeshBasicMaterial({ map: loadColorTexture('https://fastly.picsum.photos/id/13/2500/1667.jpg?hmac=SoX9UoHhN8HyklRA4A3vcCWJMVtiBXUg0W4ljWTor7s')}),
                    new THREE.MeshBasicMaterial({ map: loadColorTexture('https://fastly.picsum.photos/id/17/2500/1667.jpg?hmac=HD-JrnNUZjFiP2UZQvWcKrgLoC_pc_ouUSWv8kHsJJY')}),
                    new THREE.MeshBasicMaterial({ map: loadColorTexture('https://fastly.picsum.photos/id/18/2500/1667.jpg?hmac=JR0Z_jRs9rssQHZJ4b7xKF82kOj8-4Ackq75D_9Wmz8')}),
                    new THREE.MeshBasicMaterial({ map: loadColorTexture('https://fastly.picsum.photos/id/47/4272/2848.jpg?hmac=G8dXSLa-ngBieraQt5EORu-4r6tveX3fhvBTZM0Y8xM')}),
                    new THREE.MeshBasicMaterial({ map: loadColorTexture('https://fastly.picsum.photos/id/74/4288/2848.jpg?hmac=q02MzzHG23nkhJYRXR-_RgKTr6fpfwRgcXgE0EKvNB8')})
                ]
                

            // create a Mesh, which reps Geometry (shape of obj), Material, position/orientation/scale of obj relative to parent (the scene)
                const cube = new THREE.Mesh(geometry, materials);
                scene.add(cube); // adds non-rotating cube
                cubes.push(cube);
                cube.position.set(0, 6, 0);
                // render the scene by calling renderer's render fn + passing in scene and camera
                // renderer.render(scene, camera); --> call in render()
                renderer.setSize(500, 250, false);
            // for texture mapping to each face of the cube:
                function loadColorTexture(path) {
                    const texture = loader.load(path);
                    texture.colorSpace = THREE.SRGBColorSpace;
                    return texture;
                }
                function setScissorForElement(elem) {
                    const canvasRect = canvas.getBoundingClientRect();
                    const elemRect = elem.getBoundingClientRect();
                    
                    // compute a canvas relative rectangle
                    const right = Math.min(elemRect.right, canvasRect.right) - canvasRect.left;
                    const left = Math.max(0, elemRect.left - canvasRect.left);
                    const bottom = Math.min(elemRect.bottom, canvasRect.bottom) - canvasRect.top;
                    const top = Math.max(0, elemRect.top - canvasRect.top);
                    
                    const width = Math.min(canvasRect.width, right - left);
                    const height = Math.min(canvasRect.height, bottom - top);
                    
                    // setup the scissor to only render to that part of the canvas
                    const positiveYUpBottom = canvasRect.height - bottom;
                    renderer.setScissor(left, positiveYUpBottom, width, height);
                    renderer.setViewport(left, positiveYUpBottom, width, height);
                    
                    // return the aspect
                    return width / height;
                }


            // RENDERING FUNCTION
            function render(time) {
                time *= 0.001; // converts time --> seconds

                cubes.forEach((cube, ndx) => {
                    const speed = .2 + ndx * .1;
                    const rot = time*speed;
                    cube.rotation.x = rot;
                    cube.rotation.y = rot;
                });

                renderer.render(scene, camera);
                requestAnimationFrame(render); // request to browser that you want to animate something
                // browser calls this fn, will re-render pg if anything updates here
                }

            // ---------- ADDING CYLINDER -----------
            function drawCylinder() {
                const radiusTop = 1;
                const radiusBottom = 1;
                const height = 1;
                const radialSegments = 8;
                const heightSegments = 1;
                const openEnded = false;
                const thetaStart = 0;
                const thetaLength = (2 * Math.PI);

                const geometry2 = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
                const material2 = new THREE.MeshPhongMaterial( { color: 0xD197EA } );
                const cylinder = new THREE.Mesh(geometry2, material2);
                scene.add(cylinder);
                cylinder.position.set(0, 6, -5);

                function animateCylinder() {
                    requestAnimationFrame(animateCylinder);
                    cylinder.rotation.x += 0.01;
                    cylinder.rotation.y += 0.01;
                    renderer.render(scene, camera);
                }
                animateCylinder();
        }


            // ---------- draw octahedron -----------
            function drawOctahedron() {
                const radius = 1;
                const detail = 1;


                const loader = new THREE.TextureLoader();
                const geometry3 = new THREE.OctahedronGeometry(radius, detail);
                const material3 = new THREE.MeshPhongMaterial( {color: 0xffffff} );
                const octahedron = new THREE.Mesh(geometry3, material3);
                scene.add(octahedron);

                octahedron.position.set(0, 6, 5);
                requestAnimationFrame(render);

                function animateOctahedron() {
                    requestAnimationFrame(animateOctahedron);
                    octahedron.rotation.x += 0.01;
                    octahedron.rotation.y += 0.01;
                    renderer.render(scene, camera);
                }

                animateOctahedron();

            }   
            
            function renderLights() {
                // (1) directional light
                let dir_color = 0xFD3B14;
                let dir_intensity = 1000;
                let dir_light = new THREE.DirectionalLight(dir_color, dir_intensity);
                dir_light.position.set(0, 3, 0);
                scene.add(dir_light); 

                // (2) create ambient light
                const amb_color = 0xB1E1FF;
                const amb_intensity = 1;
                const amb_light = new THREE.AmbientLight(amb_color, amb_intensity);
                scene.add(amb_light);

                // (3) hemisphere - basically "blended" light
                const skyColor = 0xFF000000;  // light blue
                const groundColor = 0xB97A20;  // brownish orange
                const hem_intensity = 2;
                const hem_light = new THREE.HemisphereLight(skyColor, groundColor, hem_intensity);
                scene.add(hem_light);
            }

            // drawCube();
            drawCylinder();
            drawOctahedron();  
            renderLights();

            {
                const objLoader = new OBJLoader();
                objLoader.load('https://threejs.org/manual/examples/resources/models/windmill/windmill.obj', (root) => {
                scene.add(root);
                });
            }
        }

        main();
    </script>
<p>The three shapes I have are a cylinder (left), cube (middle), and octahedron (right).</p>
</body>

</html>

